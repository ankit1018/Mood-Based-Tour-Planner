{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "f54a60a1-f926-4e08-8fdf-325a384da305",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[nltk_data] Downloading package vader_lexicon to\n",
      "[nltk_data]     C:\\Users\\ankit\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package vader_lexicon is already up-to-date!\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "ü§ñ Q1: How are you feeling today?\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "You:  upset\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "ü§ñ Q2: What happened to make you feel upset?\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "You:  sad\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "ü§ñ Q3: Okay, given the user has expressed feeling \"upset\" and \"sad,\"  a good next question would be:\n",
      "\n",
      "\"What or who is making you feel so sad and upset right now?\"\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "You:  hello\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "ü§ñ Q4: Given the initial answers (\"upset,\" \"sad,\" and then a seemingly neutral \"hello\"),  it seems the user might be trying to open up but is hesitant or unsure how to express themselves fully.  Therefore, a gentle, open-ended question is appropriate:\n",
      "\n",
      "\"Can you tell me a little more about what's making you feel sad today?\"\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "You:  upset\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "ü§ñ Q5: Given the responses \"upset,\" \"sad,\" \"hello,\" and \"upset,\" it's clear the user is experiencing recurring negative emotions.  The \"hello\" might be a distraction or a way to avoid directly addressing their feelings. Therefore, a good next question would be something that gently probes for the source of their upset, acknowledging the potential for avoidance:\n",
      "\n",
      "\"It sounds like you've been feeling pretty upset and sad. Is there anything specific that's been bothering you, or is it a general feeling?\"\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "You:  sad\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "üéØ Your mood is detected as: **Angry/Frustrated**\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "\n",
      "üìç Your current city:  Kolkata\n",
      "How far do you want to travel (in km)?  700\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "üåÜ Top 25 Recommended Cities Based on Your Mood & Distance:\n",
      " - Balasore\n",
      " - Midnapore\n",
      " - Mandarmani\n",
      " - Lachung\n",
      " - Puri\n",
      " - Ranchi\n",
      " - Dhanbad\n",
      " - Konark\n",
      " - Digha\n",
      " - Ganjam\n",
      " - Rourkela\n",
      " - Durgapur\n",
      " - Sambalpur\n",
      " - Gangtok\n",
      " - Siliguri\n",
      " - Gaya\n",
      " - Pelling\n",
      " - Jamshedpur\n",
      " - Howrah\n",
      " - Rajgir\n",
      " - Purulia\n",
      " - Darjeeling\n",
      " - Deoghar\n",
      " - Kolkata\n",
      " - Cuttack\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Choose any one of the city:  Kolkata\n",
      "Enter number of days:  4\n",
      "Enter check-in date (YYYY-MM-DD):  2025-07-30\n",
      "Enter check-out date (YYYY-MM-DD):  2025-08-03\n",
      "Enter the maximum distance you can travel in a day (in km):  15\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Hotel preference options:\n",
      "1. No Preference\n",
      "2. Swimming Pool\n",
      "3. Bar\n",
      "4. Gym\n",
      "5. Spa\n",
      "6. Parking\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter your choice (1/2/3/4/5/6):  2\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Zone 1:\n",
      "  Day 1:\n",
      "    - Kalighat Mandir (22.5202798, 88.3420877)\n",
      "    - Victoria Memorial (22.5448082, 88.3425578)\n",
      "    - SREE GURUVAYURAPPAN TEMPLE (22.5208143, 88.34984829999999)\n",
      "    - Lascar War Memorial (22.55298649999999, 88.3286861)\n",
      "  Day 2:\n",
      "    - CATHEDRAL OF THE MOST HOLY ROSARY (22.5784735, 88.35264459999999)\n",
      "    - Howrah Bridge (22.5851545, 88.3468342)\n",
      "    - Indian Museum (22.55788579999999, 88.3511268)\n",
      "    - Lord Jesus Church (22.558288, 88.3579936)\n",
      "    - Heavenly¬Æ Steps Travel Private Limited (22.5725671, 88.35591819999999)\n",
      "    - Quick-O-City (22.5691049, 88.35702769999999)\n",
      "    - Acharya Bhaban (22.5793717, 88.3736787)\n",
      "    - Himachal Pradesh Helpline Tourism (22.5667774, 88.3533321)\n",
      "    - Writers' Building (22.5738409, 88.3487808)\n",
      "    - Kolkata Police Museum (22.5827884, 88.37375469999999)\n",
      "    - Himachal Tours (22.568401, 88.3486958)\n",
      "    - St. Anthony's Shrine (22.55989079999999, 88.3554736)\n",
      "  Day 3:\n",
      "    - Auxilium Parish (22.5437225, 88.3820013)\n",
      "    - Church of Our Lady of Vailankani (22.5237568, 88.39336349999999)\n",
      "\n",
      "Recommended hotels\n",
      "  - SPOT ON Dear Hotel | ‚Çπ8788.08 | Mirza Ghalib Street, Park Street | 0.41 km\n",
      "\n",
      "Best recommended hotels with 'swimming pool'\n",
      "  - Sonar Bangla Guest House - Best Guest House In Esplanade | New Market | Dharmtala | 135, Collin St, New Market Area, Janbazar, Taltala, Kolkata, West Bengal 700016, India | ‚≠ê 4.7 | 0.11 km\n",
      "  - Astoria Hotel - Kolkata | 6/2, Sudder St, opposite Fire Brigade Head Quarter, Fire Brigade Head Quarter, New Market Area, Dharmatala, Taltala, Kolkata, West Bengal 700016, India | ‚≠ê 3.4 | 0.22 km\n",
      "  - Hotel Afsha | 22, Marquis St, New Market Area, Janbazar, Taltala, Kolkata, West Bengal 700016, India | ‚≠ê 3.4 | 0.24 km\n",
      "  - Hotel Walson | 5A, Sudder St, Fire Brigade Head Quarter, New Market Area, Dharmatala, Taltala, Kolkata, West Bengal 700016, India | ‚≠ê 3.9 | 0.27 km\n",
      "  - Hotel Angina | 7/1, Marquis St, Esplanade, Taltala, Kolkata, West Bengal 700016, India | ‚≠ê 3.5 | 0.27 km\n",
      "\n",
      "Zone 2:\n",
      "  Day 4:\n",
      "    - Belur Math (22.6326565, 88.3563815)\n",
      "    - Dakshineswar Kali Temple (22.654884, 88.3576911)\n",
      "\n",
      "Recommended hotels\n",
      "  - Hotel O Arati House | ‚Çπ10342.77 | 122/45J, J. N Mukherjee Road, Ghusuri, Beside Ghusuri shyam Mandir, Howrah, Kolkata | 3.36 km\n",
      "  - Xpress Inn | ‚Çπ9367.39 | 46, Belghoria Expy, Rabindra Nagar, Alipore, Nimta | 4.96 km\n",
      "  - Hotel O Westin Regency | ‚Çπ7972.99 | Plot number- 11Monoharpur, North Subash Pally, Dankuni | 7.5 km\n",
      "  - Spot On Silver Green | ‚Çπ6933.23 | Mondal Ganthi, Post Office AirportMondal Ganthi Road, Kaikhali, VIP Road , West Bengal, Kolkata | 7.87 km\n",
      "\n",
      "Best recommended hotels with 'swimming pool'\n",
      "  - Sivalika Inn (A unit of Sivalika Hotels LLP) | 2, Watkins Ln, Babudanga, Pilkhana, Howrah, West Bengal 711101, India | ‚≠ê 3.6 | 5.88 km\n",
      "  - Hotel Kiaan Inn | 44147, Burn Salt Gola - Becharam Chowdhury Ln, Howrah AC Market, Kolkata, Howrah, West Bengal 711101, India | ‚≠ê 3.8 | 5.94 km\n",
      "  - Hotel Meghdoot | P-3A, Dobson Ln, Gulmohar Railway Quarters, Mali Panchghara, Howrah, West Bengal 711101, India | ‚≠ê 3.2 | 6.46 km\n",
      "  - Hotel Manish | P1, Dobson Ln, Gulmohar Railway Quarters, Mali Panchghara, Howrah, West Bengal 711101, India | ‚≠ê 3.3 | 6.5 km\n",
      "  - Komal collection | 177-179, Mahatma Gandhi Rd, Central Avenue, Bara Bazar, Barabazar Market, Kolkata, West Bengal 700007, India | ‚≠ê 3.8 | 6.99 km\n"
     ]
    }
   ],
   "source": [
    "# === SETUP & IMPORTS === #\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import torch\n",
    "import nltk\n",
    "import requests\n",
    "import http.client\n",
    "import json\n",
    "import time\n",
    "import googlemaps\n",
    "from nltk.sentiment import SentimentIntensityAnalyzer\n",
    "from statistics import mean\n",
    "from geopy.distance import geodesic\n",
    "from sklearn.cluster import KMeans\n",
    "import google.generativeai as genai\n",
    "\n",
    "nltk.download('vader_lexicon')\n",
    "\n",
    "# === API CONFIG === #\n",
    "GOOGLE_API_KEY = \"AIzaSyC8u9BVEnc9yOESOIj9Kg3ko-yQyZBxgII\"\n",
    "GEMINI_API_KEY = \"AIzaSyD5L_yALvZbUJHtsolaWQqk8zdy3Ov8AVA\"\n",
    "genai.configure(api_key=GEMINI_API_KEY)\n",
    "gmaps = googlemaps.Client(key=GOOGLE_API_KEY)\n",
    "gemini_model = genai.GenerativeModel(\"gemini-1.5-flash\")\n",
    "sia = SentimentIntensityAnalyzer()\n",
    "\n",
    "# === CATEGORY ‚Üí MOOD === #\n",
    "categories = [\"Beaches\", \"Spas\", \"Nature Reserves\", \"Quiet Resorts\", \"Hiking Trails\",\n",
    "    \"Mountain Expeditions\", \"Scuba Diving\", \"Vineyards\", \"Urban Centers\",\n",
    "    \"Amusement Parks\", \"Nightlife Hotspots\", \"Historic Sites\", \"Art Galleries\",\n",
    "    \"Nature Walks\", \"Festivals\", \"Music Concerts\"]\n",
    "category_to_mood = {\n",
    "    \"Beaches\": \"Happy\", \"Spas\": \"Sad/Depressed\", \"Nature Reserves\": \"Low/Unhappy\",\n",
    "    \"Quiet Resorts\": \"Sad/Depressed\", \"Hiking Trails\": \"Angry/Frustrated\",\n",
    "    \"Mountain Expeditions\": \"Angry/Frustrated\", \"Scuba Diving\": \"Angry/Frustrated\",\n",
    "    \"Vineyards\": \"Happy\", \"Urban Centers\": \"Neutral\", \"Amusement Parks\": \"Excited\",\n",
    "    \"Nightlife Hotspots\": \"Excited\", \"Historic Sites\": \"Neutral\", \"Art Galleries\": \"Sad/Depressed\",\n",
    "    \"Nature Walks\": \"Low/Unhappy\", \"Festivals\": \"Excited\", \"Music Concerts\": \"Excited\"\n",
    "}\n",
    "mood_map = {\n",
    "    (-1.0, -0.3): \"Angry/Frustrated\", (-0.3, -0.2): \"Sad/Depressed\",\n",
    "    (-0.2, -0.1): \"Low/Unhappy\", (-0.1, 0.1): \"Neutral\",\n",
    "    (0.1, 0.3): \"Happy\", (0.3, 1.0): \"Excited\"\n",
    "}\n",
    "def get_mood_from_score(score):\n",
    "    for (low, high), mood in mood_map.items():\n",
    "        if low <= score <= high:\n",
    "            return mood\n",
    "    return \"Neutral\"\n",
    "\n",
    "# === Load Dataset & Map Moods === #\n",
    "df = pd.read_csv(\"cleaned_combined_reviews.csv\")\n",
    "def extract_categories(text):\n",
    "    if pd.isna(text): return [\"Uncategorized\"]\n",
    "    text = text.lower()\n",
    "    return [cat for cat in categories if any(word in text for word in cat.lower().split())] or [\"Uncategorized\"]\n",
    "df['Categories'] = df['Review'].apply(extract_categories)\n",
    "df['Mapped_Mood'] = df['Categories'].apply(lambda clist: \", \".join({category_to_mood.get(cat, 'Neutral') for cat in clist}))\n",
    "\n",
    "# === Mood Chat === #\n",
    "def dynamic_mood_chat():\n",
    "    base_instruction = (\n",
    "        \"You are an emotional support bot. Ask 5 different questions one at a time to understand the user's emotional state. \"\n",
    "        \"Base each new question on all previous answers and inferred sentiments. Keep questions relevant to mood/emotion.\"\n",
    "    )\n",
    "\n",
    "    question = \"How are you feeling today?\"\n",
    "    sentiments, responses = [], []\n",
    "\n",
    "    for i in range(5):\n",
    "        print(f\"\\nü§ñ Q{i+1}: {question}\")\n",
    "        user_input = input(\"You: \")\n",
    "\n",
    "        responses.append(user_input)\n",
    "        compound = sia.polarity_scores(user_input)['compound']\n",
    "        sentiments.append(compound)\n",
    "\n",
    "        if i < 4:\n",
    "            history = \"\\n\".join(\n",
    "                [f\"User Q{j+1}: \\\"{resp}\\\" (sentiment: {('positive' if sentiments[j] >= 0.05 else 'negative' if sentiments[j] <= -0.05 else 'neutral')})\"\n",
    "                 for j, resp in enumerate(responses)]\n",
    "            )\n",
    "            prompt = f\"{base_instruction}\\n{history}\\nWhat should be the next question?\"\n",
    "            question = gemini_model.generate_content(prompt).text.strip()\n",
    "\n",
    "    avg_score = mean(sentiments)\n",
    "    emotion = get_mood_from_score(avg_score)\n",
    "    print(f\"\\nüéØ Your mood is detected as: **{emotion}**\")\n",
    "    return emotion\n",
    "\n",
    "# === Nearby Cities === #\n",
    "def get_nearby_cities(all_cities, base_city, max_km):\n",
    "    nearby = []\n",
    "    for loc in all_cities:\n",
    "        try:\n",
    "            result = gmaps.distance_matrix(origins=base_city, destinations=loc, mode=\"driving\")\n",
    "            dist = float(result[\"rows\"][0][\"elements\"][0][\"distance\"][\"text\"].split()[0].replace(\",\", \"\"))\n",
    "            if dist <= max_km + 100:\n",
    "                nearby.append((loc, dist))\n",
    "        except:\n",
    "            continue\n",
    "    return nearby\n",
    "\n",
    "# === Rank Cities === #\n",
    "def get_top_25_ranked_cities(filtered_df):\n",
    "    filtered_df['Sentiment_Score'] = filtered_df['Review'].apply(lambda r: sia.polarity_scores(str(r))['compound'])\n",
    "    filtered_df['Review_Length'] = filtered_df['Review'].apply(lambda r: len(str(r).split()))\n",
    "    grouped = filtered_df.groupby(\"City\").agg({\n",
    "        \"Sentiment_Score\": \"mean\",\n",
    "        \"Review_Length\": \"mean\",\n",
    "        \"Review\": \"count\"\n",
    "    }).rename(columns={\"Review\": \"Review_Count\"})\n",
    "    grouped[\"Score\"] = (\n",
    "        0.5 * grouped[\"Sentiment_Score\"] +\n",
    "        0.3 * np.log1p(grouped[\"Review_Count\"]) +\n",
    "        0.2 * np.log1p(grouped[\"Review_Length\"])\n",
    "    )\n",
    "    return grouped.sort_values(\"Score\", ascending=False).head(25).index.tolist()\n",
    "\n",
    "# === MAIN: City Recommendation === #\n",
    "def mood_to_city_recommendation():\n",
    "    emotion = dynamic_mood_chat()\n",
    "    all_cities = df['City'].dropna().unique().tolist()\n",
    "\n",
    "    base_city = input(\"\\nüìç Your current city: \")\n",
    "    max_km = int(input(\"How far do you want to travel (in km)? \"))\n",
    "    raw_nearby = get_nearby_cities(all_cities, base_city, max_km)\n",
    "\n",
    "    if not raw_nearby:\n",
    "        print(\"‚ùå No nearby cities found within travel range.\")\n",
    "        return None\n",
    "\n",
    "    nearby_cities = [c[0] for c in raw_nearby]\n",
    "    filtered_df = df[df['City'].isin(nearby_cities)].copy()\n",
    "    top_cities = get_top_25_ranked_cities(filtered_df)\n",
    "\n",
    "    print(\"\\nüåÜ Top 25 Recommended Cities Based on Your Mood & Distance:\")\n",
    "    for city in top_cities:\n",
    "        print(f\" - {city}\")\n",
    "\n",
    "    return top_cities\n",
    "\n",
    "# Get tourist attractions from Google Places API\n",
    "def get_tourist_places(city, api_key):\n",
    "    geocode_url = f\"https://maps.googleapis.com/maps/api/geocode/json?address={city}&key={api_key}\"\n",
    "    geocode_response = requests.get(geocode_url).json()\n",
    "\n",
    "    if geocode_response[\"status\"] != \"OK\":\n",
    "        return \"Error: Unable to fetch location data\"\n",
    "\n",
    "    location = geocode_response[\"results\"][0][\"geometry\"][\"location\"]\n",
    "    lat, lng = location[\"lat\"], location[\"lng\"]\n",
    "\n",
    "    places_url = \"https://maps.googleapis.com/maps/api/place/nearbysearch/json\"\n",
    "    params = {\n",
    "        \"location\": f\"{lat},{lng}\",\n",
    "        \"radius\": 10000,\n",
    "        \"type\": \"tourist_attraction\",\n",
    "        \"key\": api_key\n",
    "    }\n",
    "\n",
    "    response = requests.get(places_url, params=params).json()\n",
    "\n",
    "    if response[\"status\"] != \"OK\":\n",
    "        return \"Error: Unable to fetch tourist attractions\"\n",
    "\n",
    "    places = response.get(\"results\", [])\n",
    "    return [{\"name\": p[\"name\"], \"lat\": p[\"geometry\"][\"location\"][\"lat\"], \"lng\": p[\"geometry\"][\"location\"][\"lng\"]} for p in places]\n",
    "\n",
    "# Cluster tourist attractions based on number of travel days\n",
    "def cluster_tourist_places(places, num_days):\n",
    "    coords = np.array([[p[\"lat\"], p[\"lng\"]] for p in places])\n",
    "    kmeans = KMeans(n_clusters=min(num_days, len(places)), random_state=42, n_init=10).fit(coords)\n",
    "    labels = kmeans.labels_\n",
    "\n",
    "    clusters = {f\"Day {i+1}\": [] for i in range(num_days)}\n",
    "    day_to_cluster = {}\n",
    "    for i, place in enumerate(places):\n",
    "        day_label = f\"Day {labels[i] + 1}\"\n",
    "        clusters[day_label].append(place)\n",
    "        day_to_cluster[place[\"name\"]] = day_label\n",
    "\n",
    "    return clusters, day_to_cluster\n",
    "\n",
    "# Cluster all tourist places into zones based on max_distance\n",
    "def cluster_into_zones(places, max_distance):\n",
    "    coords = np.array([[p[\"lat\"], p[\"lng\"]] for p in places])\n",
    "    num_clusters = 1\n",
    "    while True:\n",
    "        kmeans = KMeans(n_clusters=num_clusters, random_state=42, n_init=10).fit(coords)\n",
    "        labels = kmeans.labels_\n",
    "        centroids = kmeans.cluster_centers_\n",
    "\n",
    "        valid = True\n",
    "        for i in range(num_clusters):\n",
    "            cluster_points = coords[labels == i]\n",
    "            centroid = centroids[i]\n",
    "            if any(geodesic((lat, lng), centroid).km > max_distance / 2 for lat, lng in cluster_points):\n",
    "                valid = False\n",
    "                break\n",
    "\n",
    "        if valid:\n",
    "            break\n",
    "        num_clusters += 1\n",
    "\n",
    "    zones = {f\"Zone {i+1}\": [] for i in range(num_clusters)}\n",
    "    zone_assignments = {}\n",
    "    for i, place in enumerate(places):\n",
    "        zone_label = f\"Zone {labels[i] + 1}\"\n",
    "        zones[zone_label].append(place)\n",
    "        zone_assignments[place[\"name\"]] = zone_label\n",
    "\n",
    "    return zones, centroids, zone_assignments\n",
    "\n",
    "# Booking.com hotels\n",
    "def get_booking_hotels(lat, lng, checkin_date, checkout_date):\n",
    "    conn = http.client.HTTPSConnection(\"booking-com.p.rapidapi.com\")\n",
    "\n",
    "    headers = {\n",
    "        'x-rapidapi-key': \"830829f7e2msh9ad98ebc4db50ebp1509bcjsn786be9fe7363\",\n",
    "        'x-rapidapi-host': \"booking-com.p.rapidapi.com\"\n",
    "    }\n",
    "\n",
    "    url = (\n",
    "        f\"/v1/hotels/search-by-coordinates?\"\n",
    "        f\"children_ages=5%2C0&page_number=0&categories_filter_ids=class%3A%3A2%2Cclass%3A%3A4%2Cfree_cancellation%3A%3A1\"\n",
    "        f\"&units=metric&adults_number=2&locale=en-gb&longitude={lng}&latitude={lat}\"\n",
    "        f\"&children_number=2&room_number=1&checkin_date={checkin_date}&include_adjacency=true\"\n",
    "        f\"&filter_by_currency=INR&order_by=popularity&checkout_date={checkout_date}\"\n",
    "    )\n",
    "\n",
    "    conn.request(\"GET\", url, headers=headers)\n",
    "    res = conn.getresponse()\n",
    "    data = res.read()\n",
    "    decoded = json.loads(data.decode(\"utf-8\"))\n",
    "\n",
    "    hotels = []\n",
    "    for h in decoded.get(\"result\", []):\n",
    "        if h.get(\"price_breakdown\") and h.get(\"price_breakdown\").get(\"gross_price\"):\n",
    "            hotels.append({\n",
    "                \"name\": h.get(\"hotel_name\"),\n",
    "                \"lat\": h.get(\"latitude\"),\n",
    "                \"lng\": h.get(\"longitude\"),\n",
    "                \"price\": h[\"price_breakdown\"][\"gross_price\"],\n",
    "                \"address\": h.get(\"address\", \"No address\"),\n",
    "            })\n",
    "    return hotels\n",
    "\n",
    "# Google Places API text search\n",
    "def get_hotels_with_bar_or_pool(city_name, api_key, max_results_per_type=40):\n",
    "    def fetch_hotels(query):\n",
    "        url = \"https://maps.googleapis.com/maps/api/place/textsearch/json\"\n",
    "        params = {\"query\": query, \"key\": api_key}\n",
    "        hotels = []\n",
    "        while True:\n",
    "            response = requests.get(url, params=params).json()\n",
    "            if response[\"status\"] != \"OK\": break\n",
    "            for result in response.get(\"results\", []):\n",
    "                hotels.append({\n",
    "                    \"name\": result.get(\"name\"),\n",
    "                    \"address\": result.get(\"formatted_address\"),\n",
    "                    \"lat\": result[\"geometry\"][\"location\"][\"lat\"],\n",
    "                    \"lng\": result[\"geometry\"][\"location\"][\"lng\"],\n",
    "                    \"rating\": result.get(\"rating\", \"N/A\"),\n",
    "                    \"user_ratings_total\": result.get(\"user_ratings_total\", 0)\n",
    "                })\n",
    "            if len(hotels) >= max_results_per_type or \"next_page_token\" not in response: break\n",
    "            time.sleep(2)\n",
    "            params = {\"pagetoken\": response[\"next_page_token\"], \"key\": api_key}\n",
    "        return hotels[:max_results_per_type]\n",
    "\n",
    "    types = [\"bar\", \"swimming pool\", \"gym\", \"spa\", \"parking\"]\n",
    "    all_hotels = {}\n",
    "    for facility in types:\n",
    "        fetched = fetch_hotels(f\"hotels with {facility} in {city_name}\")\n",
    "        for h in fetched:\n",
    "            all_hotels[h['name']] = h\n",
    "\n",
    "    return list(all_hotels.values())\n",
    "\n",
    "# Zone mapper\n",
    "def map_days_to_zones(day_clusters, zone_assignments):\n",
    "    day_zone_map = {}\n",
    "    for day, places in day_clusters.items():\n",
    "        zone_count = {}\n",
    "        for p in places:\n",
    "            zone = zone_assignments.get(p[\"name\"])\n",
    "            if zone:\n",
    "                zone_count[zone] = zone_count.get(zone, 0) + 1\n",
    "        if zone_count:\n",
    "            assigned_zone = max(zone_count, key=zone_count.get)\n",
    "            day_zone_map.setdefault(assigned_zone, []).append(day)\n",
    "    return day_zone_map\n",
    "\n",
    "# Skyline filter\n",
    "def skyline_hotels(hotels, center_coords):\n",
    "    filtered = []\n",
    "    for h in hotels:\n",
    "        try:\n",
    "            h[\"price\"] = float(h[\"price\"])\n",
    "        except:\n",
    "            h[\"price\"] = float(\"inf\")\n",
    "        h[\"distance\"] = geodesic((h[\"lat\"], h[\"lng\"]), center_coords).km\n",
    "\n",
    "    for h in hotels:\n",
    "        dominated = False\n",
    "        for other in hotels:\n",
    "            if (\n",
    "                other[\"price\"] <= h[\"price\"] and\n",
    "                other[\"distance\"] <= h[\"distance\"] and\n",
    "                (other[\"price\"] < h[\"price\"] or other[\"distance\"] < h[\"distance\"])\n",
    "            ):\n",
    "                dominated = True\n",
    "                break\n",
    "        if not dominated:\n",
    "            filtered.append(h)\n",
    "    return filtered\n",
    "\n",
    "# === EXECUTE FIRST PART === #\n",
    "if __name__ == \"__main__\":\n",
    "    top_city_list = mood_to_city_recommendation()\n",
    "    if top_city_list:\n",
    "        name_city = input(\"Choose any one of the city: \")\n",
    "        city_name = name_city\n",
    "        num_days = int(input(\"Enter number of days: \"))\n",
    "        checkin_date = input(\"Enter check-in date (YYYY-MM-DD): \").strip()\n",
    "        checkout_date = input(\"Enter check-out date (YYYY-MM-DD): \").strip()\n",
    "        max_travel_distance = float(input(\"Enter the maximum distance you can travel in a day (in km): \"))\n",
    "\n",
    "        tourist_places = get_tourist_places(city_name, GOOGLE_API_KEY)\n",
    "\n",
    "        if isinstance(tourist_places, list) and tourist_places:\n",
    "            day_clusters, _ = cluster_tourist_places(tourist_places, num_days)\n",
    "            zones, centroids, zone_assignments = cluster_into_zones(tourist_places, max_travel_distance)\n",
    "            day_zone_map = map_days_to_zones(day_clusters, zone_assignments)\n",
    "\n",
    "            print(\"\\nHotel preference options:\")\n",
    "            print(\"1. No Preference\")\n",
    "            print(\"2. Swimming Pool\")\n",
    "            print(\"3. Bar\")\n",
    "            print(\"4. Gym\")\n",
    "            print(\"5. Spa\")\n",
    "            print(\"6. Parking\")\n",
    "            hotel_pref_choice = input(\"Enter your choice (1/2/3/4/5/6): \").strip()\n",
    "            preference_map = {\n",
    "                \"1\": \"none\",\n",
    "                \"2\": \"swimming pool\",\n",
    "                \"3\": \"bar\",\n",
    "                \"4\": \"gym\",\n",
    "                \"5\": \"spa\",\n",
    "                \"6\": \"parking\"\n",
    "            }\n",
    "            hotel_preference = preference_map.get(hotel_pref_choice, \"none\")\n",
    "\n",
    "            if hotel_preference != \"none\":\n",
    "                preferred_hotels = get_hotels_with_bar_or_pool(city_name, GOOGLE_API_KEY)\n",
    "\n",
    "            day_counter = 1\n",
    "            for zone_label, zone_places in zones.items():\n",
    "                print(f\"\\n{zone_label}:\")\n",
    "                assigned_days = sorted(day_zone_map.get(zone_label, []), key=lambda x: int(x.split(' ')[1]))\n",
    "\n",
    "                for day in assigned_days:\n",
    "                    print(f\"  Day {day_counter}:\")\n",
    "                    day_counter += 1\n",
    "                    for place in day_clusters.get(day, []):\n",
    "                        print(f\"    - {place['name']} ({place['lat']}, {place['lng']})\")\n",
    "\n",
    "                centroid = np.mean([[p[\"lat\"], p[\"lng\"]] for p in zone_places], axis=0)\n",
    "                zone_hotels = get_booking_hotels(centroid[0], centroid[1], checkin_date, checkout_date)\n",
    "                if zone_hotels:\n",
    "                    skyline = skyline_hotels(zone_hotels, centroid)\n",
    "                    print(\"\\nRecommended hotels\")\n",
    "                    for hotel in skyline:\n",
    "                        print(f\"  - {hotel['name']} | ‚Çπ{hotel['price']} | {hotel['address']} | {round(hotel['distance'], 2)} km\")\n",
    "\n",
    "                    if hotel_preference != \"none\":\n",
    "                        print(f\"\\nBest recommended hotels with '{hotel_preference}'\")\n",
    "                        for hotel in preferred_hotels:\n",
    "                            hotel[\"distance\"] = geodesic((hotel[\"lat\"], hotel[\"lng\"]), centroid).km\n",
    "                        preferred_hotels_sorted = sorted(preferred_hotels, key=lambda h: h[\"distance\"])\n",
    "                        for hotel in preferred_hotels_sorted[:5]:\n",
    "                            print(f\"  - {hotel['name']} | {hotel['address']} | ‚≠ê {hotel['rating']} | {round(hotel['distance'], 2)} km\")\n",
    "                else:\n",
    "                    print(\"‚ùå No hotel found in this zone.\")\n",
    "        else:\n",
    "            print(tourist_places)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fd1d3859-125c-47be-b698-ad9ca4dd60b8",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
